{
  "0": {
    "id": "0",
    "title": "",
    "content": "404 Page not found :( The requested page could not be found.",
    "url": "/jersey-netty-cdi-jackson-file-eventstore/404.html",
    "relUrl": "/404.html"
  },
  "1": {
    "id": "1",
    "title": "Jersey Netty CDI Jackson File EventStore",
    "content": "Jersey Netty CDI Jackson File EventStore Building File based event-store with Jackson JSON Serialisation / Deserialization, Jersey REST API uses Netty runtime and Weld CDI Jersey (Netty) and CDI tiny, fast and dead-simple! pom.xml &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;mainClass&gt;daggerok.Main&lt;/mainClass&gt; &lt;jersey.version&gt;2.29&lt;/jersey.version&gt; &lt;jandex.version&gt;2.1.1.Final&lt;/jandex.version&gt; &lt;jandex-maven-plugin.version&gt;1.0.6&lt;/jandex-maven-plugin.version&gt; &lt;capsule-maven-plugin.version&gt;1.5.1&lt;/capsule-maven-plugin.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;${jandex.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi2-se&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; &lt;artifactId&gt;jersey-container-netty-http&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- CDI index --&gt; &lt;plugin&gt; &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt; &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${jandex-maven-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-index&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jandex&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- fat jar --&gt; &lt;plugin&gt; &lt;groupId&gt;com.github.chrisdchristo&lt;/groupId&gt; &lt;artifactId&gt;capsule-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${capsule-maven-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;fileDesc&gt;-all&lt;/fileDesc&gt; &lt;appClass&gt;${mainClass}&lt;/appClass&gt; &lt;type&gt;fat&lt;/type&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; entry point Main.java @Log4j2 public class Main extends ResourceConfig { public Main() { packages(true, Main.class.getPackage().getName()); } public static void main(String[] args) { Channel server = NettyHttpContainerProvider.createHttp2Server( URI.create(&quot;http://127.0.0.1:8080/&quot;), ResourceConfig.forApplicationClass(Main.class), null); Runtime.getRuntime().addShutdownHook(new Thread(server::close)); } } fallback ErrorMapper.java @Log4j2 @Provider @RequestScoped public class ErrorMapper implements ExceptionMapper&lt;Exception&gt; { @Context UriInfo uriInfo; @Context Request request; @Override public Response toResponse(Exception exception) { log.warn(&quot;{} {}&quot;, request.getMethod(), exception.getLocalizedMessage(), exception); return Response.status(Response.Status.BAD_REQUEST) .entity(Json.createObjectBuilder() .add(&quot;error&quot;, Optional.ofNullable(exception.getLocalizedMessage()) .orElse(&quot;empty&quot;)) .add(&quot;_links&quot;, Json.createObjectBuilder() .add(&quot;_self&quot;, uriInfo.getAbsolutePath() .toString()) .build()) .build()) .type(MediaType.APPLICATION_JSON) .build(); } } HealthResource.java + some fallback also: @RequestScoped @Consumes(WILDCARD) @Produces(APPLICATION_JSON) public class HealthResource { private void on(@Observes ContainerInitialized containerInitializedEvent) { log.info(containerInitializedEvent); } @GET @Path(&quot;health&quot;) public JsonObject health() { log.info(&quot;health&quot;); return Json.createObjectBuilder() .add(&quot;status&quot;, &quot;UP&quot;) .build(); } @GET @Path(&quot;{path:(.*)?}&quot;) public JsonObject getAny(@PathParam(&quot;path&quot;) String path) { log.info(&quot;unexpected GET&quot;); return info(path); } private JsonObject info(String path) { return Json.createObjectBuilder() .add(&quot;path&quot;, &quot;&quot; + path) .build(); } } Jackson JSON support maven dependencies in pom.xml file &lt;properties&gt; &lt;jersey.version&gt;2.29&lt;/jersey.version&gt; &lt;jackson.version&gt;2.10.0.pr2&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-bom&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Jackson Jersey support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; &lt;artifactId&gt;jersey-container-netty-http&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 1. Serialization / Deserialization of abstract types (such as DomainEvent) by using Jackson type feature 2. REST API: Input List of DomainEvents as Request Body --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- REST API: javax.json.Json / javax.json.JsonObject --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-processing&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Jackson ObjectMapper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- ZonedDateTime Format and Serialization / Deserialization --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; In order to let Jackson properly understand how to deserialize json into abstract type, we have to configure its abstract type mappings (see @@JsonSubTypes annotations): DomainEvent.java @JsonTypeInfo( use = JsonTypeInfo.Id.NAME, property = &quot;type&quot; ) @JsonSubTypes({ @JsonSubTypes.Type(name = &quot;CounterCreated&quot;, value = CounterCreated.class), @JsonSubTypes.Type(name = &quot;CounterIncremented&quot;, value = CounterIncremented.class), @JsonSubTypes.Type(name = &quot;CounterSuspended&quot;, value = CounterSuspended.class), }) public interface DomainEvent { UUID getAggregateId(); } All events are ValueObjects and can be created only via single constructor. In order to help Jackson properly understand how all these events can be deserialized into Java Object, we have to setup it’s @JsonCreator together with @JsonProperty pointing to concrete object field… Also, we don’t wanna show any empty or null fields in case they are has not been specified, so we are using @JsonInclude annotations… By design, all our event should should be relative to concrete aggregate, so they should have aggregateId as well: @Data public class CounterCreated implements DomainEvent { private final String eventName = CounterCreated.class.getSimpleName(); @JsonInclude(JsonInclude.Include.NON_NULL) private final UUID aggregateId; @JsonInclude(JsonInclude.Include.NON_EMPTY) private final String counterName; @JsonInclude(JsonInclude.Include.NON_NULL) @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;) private final ZonedDateTime at; @JsonCreator public CounterCreated(@JsonProperty(&quot;aggregateId&quot;) UUID aggregateId, @JsonProperty(&quot;counterName&quot;) String counterName, @JsonProperty(&quot;at&quot;) ZonedDateTime at) { this.aggregateId = Optional.of(aggregateId).orElse(UUID.randomUUID()); this.counterName = Optional.ofNullable(counterName).orElse(String.format(&quot;counter-%d&quot;, System.nanoTime())); this.at = Optional.ofNullable(at).orElse(ZonedDateTime.now()); } } ZonedDateTime In order to have properly consumable format of java.timr.ZonedDateTime type, we have to configure Jackson ObjectMapper to be used in our serialization process in our app: JacksonConfig.java @ApplicationScoped public class JacksonConfig { @Produces private ObjectMapper objectMapper = JsonMapper.builder() .addModules(new JavaTimeModule()) .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) .disable(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS) .disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) .disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS) .build(); } But we have to also care about Jersey! So we should properly configure Jersey ObjectMapper ContextResolver via provider JacksonProvider @Provider @ApplicationScoped @Produces(MediaType.APPLICATION_JSON) public class JacksonProvider implements ContextResolver&lt;ObjectMapper&gt; { @Inject ObjectMapper objectMapper; @Override public ObjectMapper getContext(Class&lt;?&gt; type) { return objectMapper; } } Because we previously configure ObjectMapper in JacksonConfig.java file we can (and should) re-use it!",
    "url": "/jersey-netty-cdi-jackson-file-eventstore/",
    "relUrl": "/"
  },
  "2": {
    "id": "2",
    "title": "Developer Guide",
    "content": "clone repo git clone --depth=1 https://github.com/daggerok/jersey-netty-cdi-jackson-file-eventstore.git app cd app/ run fat jar ./mvnw package ; java -jar target/*-all.jar test event-stpre echo &#39;[ { &quot;type&quot;:&quot;CounterCreated&quot;, &quot;aggregateId&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;counterName&quot;: &quot;hello 1&quot; }, { &quot;type&quot;:&quot;CounterIncremented&quot;, &quot;aggregateId&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;by&quot;: &quot;max&quot;, &quot;withValue&quot;: 2 }, { &quot;type&quot;:&quot;CounterIncremented&quot;, &quot;aggregateId&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;by&quot;: &quot;max&quot;, &quot;withValue&quot;: 3 }, { &quot;type&quot;:&quot;CounterIncremented&quot;, &quot;aggregateId&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;by&quot;: &quot;max&quot; }, { &quot;type&quot;:&quot;CounterSuspended&quot;, &quot;aggregateId&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;reason&quot;: &quot;because!&quot; } ]&#39; | http post :8080/events/collection http :8080/events/00000000-0000-0000-0000-000000000000 Accept:application/json http :8080/events/00000000-0000-0000-0000-000000000001/collection Accept:application/json NOTE: This project has been based on GitHub: daggerok/main-starter (branch: maven-java) links: Overriding Jackson ObjectMapper Provider in Jersey spotbugs plugin quick project docs jekyll guide cd docs bundle bundle exec just-the-docs rake search:init bundle exec jekyll serve bundle exec jekyll build mv -v _site Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.",
    "url": "/jersey-netty-cdi-jackson-file-eventstore/docs/quick-start.html",
    "relUrl": "/docs/quick-start.html"
  }
  
}
